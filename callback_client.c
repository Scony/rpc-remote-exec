/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "callback.h"
#include <poll.h>

void cout_callback(char * host, char * data)
{
  static int seq = -1;
  CLIENT * clnt;
  int * result;
  params cout_1_arg;

  cout_1_arg.seq = ++seq;
  cout_1_arg.data = data;

  clnt = clnt_create(host,CALLBACK,V1,"udp");
  if(clnt == NULL)
    {
      clnt_pcreateerror(host);
      exit(1);
    }

  result = cout_1(&cout_1_arg, clnt);
  if(result == (int *)NULL)
    {
      clnt_perror(clnt,"cout_callback call failed");
    }

  clnt_destroy (clnt);
}

void cerr_callback(char * host, char * data)
{
  static int seq = -1;
  CLIENT * clnt;
  int * result;
  params cerr_1_arg;

  cerr_1_arg.seq = ++seq;
  cerr_1_arg.data = data;

  clnt = clnt_create(host,CALLBACK,V1,"udp");
  if(clnt == NULL)
    {
      clnt_pcreateerror(host);
      exit(1);
    }

  result = cerr_1(&cerr_1_arg, clnt);
  if(result == (int *)NULL)
    {
      clnt_perror(clnt,"cerr_callback call failed");
    }

  clnt_destroy (clnt);
}

void result_callback(char * host, int rslt)
{
  CLIENT * clnt;
  int * result;
  int ret_1_arg;

  ret_1_arg = rslt;

  clnt = clnt_create(host,CALLBACK,V1,"udp");
  if(clnt == NULL)
    {
      clnt_pcreateerror(host);
      exit(1);
    }

  result = ret_1(&ret_1_arg, clnt);
  if(result == (int *)NULL)
    {
      clnt_perror(clnt,"result_callback call failed");
    }

  clnt_destroy (clnt);
}


int main(int argc, char * argv[])
{
  char * host = argv[1];

  if(argc < 3)
    {
      printf("usage: %s callback_server_host command [arguments]\n", argv[0]);
      exit(1);
    }

  int cinp[2];
  int coutp[2];
  int cerrp[2];
  pipe(cinp);
  pipe(coutp);
  pipe(cerrp);

  int f = fork();
  if(f)				/* parent */
    {
      struct pollfd fds[3];

      close(cinp[0]);
      close(coutp[1]);
      close(cerrp[1]);

      fds[0].fd = coutp[0];
      fds[0].events = POLLIN;
      fds[1].fd = cerrp[0];
      fds[1].events = POLLIN;
      fds[2].fd = 0;
      fds[2].events = POLLIN;

      int fdsc = 3;
      while(1)
	{
	  char buff[4096];
	  poll(fds,fdsc,-1);
	  memset(buff,'\0',4096);
	  if(fds[0].revents & POLLIN || fds[0].revents & POLLHUP) /* cout */
	    {
	      int rd = read(coutp[0],buff,4096);
	      if(!rd)
		break;
	      cout_callback(argv[1],buff);
	    }
	  memset(buff,'\0',4096);
	  if(fds[1].revents & POLLIN || fds[1].revents & POLLHUP) /* cerr */
	    {
	      int rd = read(cerrp[0],buff,4096);
	      if(!rd)
		break;
	      cerr_callback(argv[1],buff);
	    }
	  memset(buff,'\0',4096);
	  if(fds[2].revents & POLLIN || fds[2].revents & POLLHUP) /* cin */
	    {
	      int rd = read(0,buff,4096);
	      if(!rd)
		{
		  close(cinp[1]);
		  fdsc = 2;
		  continue;
		}
	      write(cinp[1],buff,rd);
	    }
	}

      int s;
      wait(&s);
      if(WIFEXITED(s))
	{
	  printf("Child's exit code %d\n", WEXITSTATUS(s));
	  result_callback(argv[1],WEXITSTATUS(s));
	}
      else
	printf("Child did not terminate with exit\n");
    }
  else				/* child */
    {
      dup2(cinp[0],0);
      dup2(coutp[1],1);
      dup2(cerrp[1],2);
      close(cinp[1]);
      close(coutp[0]);
      close(cerrp[0]);

      int paramsc = argc - 1;	/* argc - 2 + 1 (for NULL) */
      char * params[paramsc];
      int i;
      for(i = 0; i < paramsc - 1; i++)
	params[i] = argv[i+2];
      params[paramsc-1] = NULL;
      execv(argv[2],params);
    }

  return 0;
}
